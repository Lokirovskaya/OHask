{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

{-# HLINT ignore "Redundant return" #-}
{-# HLINT ignore "Use <$>" #-}

module Main where

import Control.Applicative ((<|>))
import Data.Dynamic (Dynamic, fromDynamic)
import DynExprs
import RandomGen

class Test a where
  testGroup :: (a -> [Dynamic]) -> IO ()

class Test2 a b where
  testGroup2 :: (a -> b -> [Dynamic]) -> IO ()

scaleDynInt :: Dynamic -> Maybe Int
scaleDynInt d = do
  -- Outer `Maybe` is generated by `fromDynamic`
  -- Inner `Maybe` is from the expr test result
  result <- fromDynamic d :: Maybe (Maybe Int)
  val <- result
  return val

scaleDynList :: Dynamic -> Maybe Int
scaleDynList d = do
  result <- fromDynamic d :: Maybe (Maybe [Int])
  val <- result
  return $ length val

scaleDyn :: Dynamic -> Maybe Int
scaleDyn d =
  scaleDynInt d <|> scaleDynList d

showDyns :: [Dynamic] -> IO ()
showDyns ds = do
  let results = map scaleDyn ds
  print results

instance Test Int where
  testGroup g = do
    x <- randInt
    showDyns $ g x

instance Test [Int] where
  testGroup g = do
    x <- randIntList
    showDyns $ g x

instance Test2 Int Int where
  testGroup2 g = do
    x1 <- randInt
    x2 <- randInt
    showDyns $ g x1 x2

instance Test2 [Int] Int where
  testGroup2 g = do
    x1 <- randIntList
    x2 <- randInt
    showDyns $ g x1 x2

instance Test2 Int [Int] where
  testGroup2 g = do
    x1 <- randInt
    x2 <- randIntList
    showDyns $ g x1 x2

instance Test2 [Int] [Int] where
  testGroup2 g = do
    x1 <- randIntList
    x2 <- randIntList
    showDyns $ g x1 x2

main :: IO ()
main = do
  testGroup2 g3
