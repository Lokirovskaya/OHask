{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

{-# HLINT ignore "Redundant return" #-}
{-# HLINT ignore "Use <$>" #-}
{-# HLINT ignore "Replace case with maybe" #-}
{-# HLINT ignore "Avoid lambda using `infix`" #-}

module TestGroup (testGroup1, testGroup2, testGroup3) where

import Data.Dynamic (Dynamic, fromDynamic)
import Data.Foldable (asum)
import RandomGen
import Result
import Scale

dynToCell :: Dynamic -> Cell
dynToCell dyn = do
  -- Outer `Maybe` is generated by `fromDynamic`
  -- Inner `Maybe` is from the expr test result
  val <-
    asum
      [ mmScale (fromDynamic dyn :: Maybe (Maybe Int)),
        mmScale (fromDynamic dyn :: Maybe (Maybe [Int]))
      ]
  return val
  where
    mmScale (Just (Just x)) = scale x
    mmScale _ = []

scaleOutput :: [Dynamic] -> [Cell]
scaleOutput = map dynToCell

makeResult :: (Scale a) => [a] -> [Dynamic] -> Result
makeResult rawInputs dynOutputs =
  let inputs = map scale rawInputs
      outputs = scaleOutput dynOutputs
   in Result {resultGroupIdx = 0, inputVals = inputs, outputVals = outputs}

testGroup1 :: (Rand t, Scale t) => (t -> [Dynamic]) -> IO Result
testGroup1 g = do
  x <- rand
  return $ makeResult [x] (g x)

testGroup2 :: (Rand t, Scale t) => (t -> t -> [Dynamic]) -> IO Result
testGroup2 g = do
  x1 <- rand
  x2 <- rand
  return $ makeResult [x1, x2] (g x1 x2)

testGroup3 :: (Rand t, Scale t) => (t -> t -> t -> [Dynamic]) -> IO Result
testGroup3 g = do
  x1 <- rand
  x2 <- rand
  x3 <- rand
  return $ makeResult [x1, x2, x3] (g x1 x2 x3)
